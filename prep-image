#!/usr/bin/perl
use strict;
use warnings;
use Image::Magick;
use Getopt::Long;
use File::Basename;

# Inky Impression 7.3" specifications
my $TARGET_WIDTH = 800;
my $TARGET_HEIGHT = 480;

# Optimal 7-color palette for Inky Impression (ACeP - Advanced Color ePaper)
# These colors work well with the 7-color e-ink display
my @EINK_PALETTE = (
    '#000000',  # Black
    '#FFFFFF',  # White  
    '#FF0000',  # Red
    '#00FF00',  # Green
    '#0000FF',  # Blue
    '#FFFF00',  # Yellow
    '#FF8000',  # Orange
);

sub usage {
    print <<EOF;
Usage: $0 [options] input_image output_image

Options:
    --help, -h          Show this help message
    --quality, -q NUM   Output JPEG quality (1-100, default: 85)
    --dither, -d        Enable dithering for better color transitions
    --preview, -p       Show palette preview in filename
    
Examples:
    $0 photo.jpg inky_photo.jpg
    $0 --dither --quality 90 landscape.jpg display_ready.jpg
    
This script prepares images for the Inky Impression 7.3" e-ink display by:
- Resizing to 800x480 pixels (maintaining aspect ratio with letterboxing)
- Converting to optimal 7-color e-ink palette
- Applying optional dithering for smoother gradients

EOF
    exit 0;
}

sub create_palette_image {
    my ($palette_ref) = @_;
    
    my $palette_img = Image::Magick->new();
    $palette_img->Set(size => '7x1');
    my $result = $palette_img->ReadImage('xc:white');
    if ($result) {
        die "Error creating palette image: $result\n";
    }
    
    # Create a proper palette by drawing colored rectangles
    for my $i (0 .. $#{$palette_ref}) {
        my $color_img = Image::Magick->new();
        $color_img->Set(size => '1x1');
        $result = $color_img->ReadImage("xc:$palette_ref->[$i]");
        if ($result) {
            warn "Warning: Could not create color $palette_ref->[$i]: $result\n";
            next;
        }
        
        $result = $palette_img->Composite(
            image => $color_img,
            x => $i,
            y => 0,
            compose => 'Over'
        );
        if ($result) {
            warn "Warning: Could not add color to palette: $result\n";
        }
    }
    
    return $palette_img;
}

sub process_image {
    my ($input_file, $output_file, $options) = @_;
    
    print "Processing: $input_file -> $output_file\n";
    
    # Load the input image
    my $image = Image::Magick->new();
    my $result = $image->Read($input_file);
    if ($result) {
        die "Error reading image: $result\n";
    }
    
    # Get original dimensions
    my ($orig_width, $orig_height) = $image->Get('width', 'height');
    print "Original size: ${orig_width}x${orig_height}\n";
    
    # Calculate resize dimensions maintaining aspect ratio
    my $scale_w = $TARGET_WIDTH / $orig_width;
    my $scale_h = $TARGET_HEIGHT / $orig_height;
    my $scale = ($scale_w < $scale_h) ? $scale_w : $scale_h;
    
    my $new_width = int($orig_width * $scale);
    my $new_height = int($orig_height * $scale);
    
    print "Scaled size: ${new_width}x${new_height}\n";
    
    # Resize the image
    $result = $image->Resize(geometry => "${new_width}x${new_height}!");
    if ($result) {
        die "Error resizing image: $result\n";
    }
    
    # Create canvas with target dimensions and white background
    my $canvas = Image::Magick->new(size => "${TARGET_WIDTH}x${TARGET_HEIGHT}");
    $canvas->ReadImage('xc:white');
    
    # Calculate position to center the resized image
    my $x_offset = int(($TARGET_WIDTH - $new_width) / 2);
    my $y_offset = int(($TARGET_HEIGHT - $new_height) / 2);
    
    # Composite the resized image onto the canvas
    $result = $canvas->Composite(
        image => $image,
        x => $x_offset,
        y => $y_offset,
        compose => 'Over'
    );
    if ($result) {
        die "Error compositing image: $result\n";
    }
    
    # Create palette image for color mapping
    my $palette_img = create_palette_image(\@EINK_PALETTE);
    
    # Alternative approach: Quantize colors to our palette
    print "Quantizing to e-ink colors...\n";
    
    # First quantize to reduce colors, then map to our specific palette
    $result = $canvas->Quantize(colors => 7, colorspace => 'RGB');
    if ($result) {
        warn "Warning: Quantization failed: $result\n";
    }
    
    # Try to map to our palette
    my $palette_img = create_palette_image(\@EINK_PALETTE);
    $result = $canvas->Map(image => $palette_img);
    
    if ($result) {
        warn "Warning: Palette mapping failed: $result\n";
        print "Continuing with quantized colors...\n";
    } else {
        print "Successfully mapped to e-ink palette\n";
    }
    
    # Apply dithering if requested (as a separate step)
    if ($options->{dither}) {
        print "Applying dithering...\n";
        # Use ordered dithering which is more reliable
        $result = $canvas->OrderedDither('o8x8');
        if ($result) {
            warn "Warning: Dithering failed: $result\n";
        } else {
            print "Applied ordered dithering\n";
        }
    }
    
    # Enhance contrast for e-ink display
    $result = $canvas->Normalize();
    if ($result) {
        warn "Warning: Could not normalize image: $result\n";
    }
    
    # Set output quality
    $canvas->Set(quality => $options->{quality});
    
    # Write the processed image
    $result = $canvas->Write($output_file);
    if ($result) {
        die "Error writing image: $result\n";
    }
    
    print "Successfully created: $output_file\n";
    print "Final size: ${TARGET_WIDTH}x${TARGET_HEIGHT}\n";
    
    # Show palette info if requested
    if ($options->{preview}) {
        print "\nE-ink palette colors used:\n";
        for my $i (0 .. $#EINK_PALETTE) {
            printf "  %d: %s\n", $i + 1, $EINK_PALETTE[$i];
        }
    }
}

# Main program
my %options = (
    quality => 85,
    dither => 0,
    preview => 0,
    help => 0,
);

GetOptions(
    'quality|q=i' => \$options{quality},
    'dither|d' => \$options{dither},
    'preview|p' => \$options{preview},
    'help|h' => \$options{help},
) or usage();

usage() if $options{help};

if (@ARGV != 2) {
    print "Error: Please specify input and output files.\n\n";
    usage();
}

my ($input_file, $output_file) = @ARGV;

# Validate input file
unless (-f $input_file) {
    die "Error: Input file '$input_file' does not exist.\n";
}

# Validate quality parameter
if ($options{quality} < 1 || $options{quality} > 100) {
    die "Error: Quality must be between 1 and 100.\n";
}

# Check if Image::Magick is available
eval { require Image::Magick; };
if ($@) {
    die "Error: Image::Magick module is required. Install with: cpan Image::Magick\n";
}

# Process the image
eval {
    process_image($input_file, $output_file, \%options);
};

if ($@) {
    die "Processing failed: $@";
}

print "\nImage prepared for Inky Impression 7.3\" display!\n";
print "You can now transfer '$output_file' to your Raspberry Pi.\n";

